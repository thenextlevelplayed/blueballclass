# 如何設計 C# 中的抽象類別與子類別：從基礎到進階應用

在 C# 中，抽象類別（Abstract Class）是一種強大的工具，用於定義通用的行為藍圖，並允許子類別根據需求實現具體邏輯。在這篇文章中，我將從基礎開始，介紹抽象類別的定義與使用，然後透過實際範例展示如何搭配泛型和子類別實現功能。同時，我會統整我在學習過程中遇到的錯誤（例如型態不匹配和子類別實作問題），並提供解決方案，幫助你避免類似的陷阱。

## 一、抽象類別的基本概念

### 什麼是抽象類別？

抽象類別是一種不能直接實例化的類別，使用 `abstract` 關鍵字定義。它通常作為基類，提供一組方法和屬性，讓子類別繼承並實現具體邏輯。抽象類別可以包含：

- **抽象方法**：標記為 `abstract`，無實作主體，子類別必須覆寫。
- **虛擬方法**：標記為 `virtual`，有預設實作，子類別可選擇覆寫。
- **具體方法**：普通方法，已有實作，子類別直接使用。

### 基本範例

以下是一個簡單的抽象類別 `DataProcessor<T>`，用於處理泛型資料：

```csharp
public abstract class DataProcessor<T>
{
    protected T Data { get; set; }

    public DataProcessor(T data)
    {
        Data = data;
    }

    public abstract string ProcessData();

    public virtual void DisplayData()
    {
        Console.WriteLine($"Data: {Data}");
    }

    public void ResetData(T newData)
    {
        Data = newData;
        Console.WriteLine("Data has been reset.");
    }
}
```

#### 子類別實現

```csharp
public class StringProcessor : DataProcessor<string>
{
    public StringProcessor(string data) : base(data) { }

    public override string ProcessData()
    {
        return $"Processed: {Data.ToUpper()}";
    }

    public override void DisplayData()
    {
        Console.WriteLine($"String Data: '{Data}' (Length: {Data.Length})");
    }
}
```

#### 使用方式

```csharp
StringProcessor processor = new StringProcessor("Hello");
processor.DisplayData(); // 輸出: String Data: 'Hello' (Length: 5)
Console.WriteLine(processor.ProcessData()); // 輸出: Processed: HELLO
processor.ResetData("World"); // 輸出: Data has been reset.
processor.DisplayData(); // 輸出: String Data: 'World' (Length: 5)
```

這個範例展示了抽象類別的基本結構：抽象方法強制子類別實作，虛擬方法提供彈性，具體方法則共享通用邏輯。

## 二、進階應用：樣板方法模式與泛型

### 樣板方法模式

樣板方法模式是一種常見的設計模式，透過抽象類別定義一個演算法的骨架，將具體步驟交給子類別實現。我在設計 `StringTemplate<T>` 時，使用了這種模式來處理字串陣列的搜尋任務。

#### 抽象類別設計

```csharp
public abstract class StringTemplate<T>
{
    public T Search(String[] messages)
    {
        T result = SetDefaultValues();
        for (int i = 0; i < messages.Length; i++)
        {
            result = UpdateResult(messages[i], i);
            Console.WriteLine(messages[i]);
            if (SearchEnd(i, messages))
            {
                break;
            }
        }
        return result;
    }

    protected abstract T UpdateResult(string messages, int index);
    protected abstract T SetDefaultValues();
    protected virtual bool SearchEnd(int index, string[] messages)
    {
        return false;
    }
}
```

- `Search` 是樣板方法，定義了遍歷、更新結果、印出訊息和終止條件的流程。
- 子類別必須實現 `UpdateResult` 和 `SetDefaultValues`，並可選擇覆寫 `SearchEnd`。

### 子類別範例 1：尋找空字串索引

```csharp
public class SearchEmptyMessageIndex : StringTemplate<int>
{
    private int index;

    protected override int SetDefaultValues()
    {
        index = 0;
        return -1; // 預設值表示未找到
    }

    protected override int UpdateResult(string message, int i)
    {
        index = i;
        return String.IsNullOrEmpty(message) ? i : -1;
    }

    protected override bool SearchEnd(int i, string[] messages)
    {
        return String.IsNullOrEmpty(messages[i]);
    }
}
```

- **功能**：尋找第一個空字串的索引，若無則回傳 -1。
- **執行結果**：
  ```
  hello
  world
  
  Empty message index: 2
  ```

### 子類別範例 2：計算 "Waterball" 數量

```csharp
public class CountNumberOfWaterballs : StringTemplate<int>
{
    private int Count;

    protected override int SetDefaultValues()
    {
        Count = 0;
        return 0;
    }

    protected override int UpdateResult(string message, int index)
    {
        if ("Waterball".Equals(message))
        {
            Count++;
        }
        return Count;
    }
}
```

- **功能**：計算字串陣列中 `"Waterball"` 的出現次數。
- **執行結果**：
  ```
  Hello
  Waterball
  World
  Waterball
  Number of 'Waterball': 2
  ```

## 三、常見錯誤與解決方案

在設計抽象類別和子類別時，我遇到了一些錯誤，以下是統整與解決方法：

### 1. 型態不匹配錯誤

#### 問題

在 `StringTemplate<T>` 中，我最初將 `SetDefaultValues` 定義為 `protected abstract T? SetDefaultValues()`，但子類別回傳的是 `int`，導致編譯錯誤：

```
Cannot implicitly convert type 'int' to 'int?'
```

#### 原因

`T?` 表示可為 null 的型別，而 `T` 是非可為 null 的型別，兩者不直接相容。

#### 解決方案

- **方法 1：統一型別為 `T`**：

  如果預設值不需要 null，改為 `protected abstract T SetDefaultValues()`。

  ```csharp
  protected abstract T SetDefaultValues();
  ```

  子類別實現：

  ```csharp
  protected override int SetDefaultValues() { return -1; }
  ```

- **方法 2：使用可為 null 的型別**：

  如果需要 null，子類別應繼承 `StringTemplate<int?>`。

  ```csharp
  public class SearchEmptyMessageIndex : StringTemplate<int?>
  {
      protected override int? SetDefaultValues() { return null; }
  }
  ```

#### 教訓

在設計泛型抽象類別時，確保父類別和子類別的型別一致，或明確處理 null 的情況。

### 2. 子類別覆寫錯誤

#### 問題

在 `SearchEmptyMessageIndex` 中，我誤將 `SearchEnd` 寫成 `EndSearch`，導致錯誤：

```
There is no suitable method for override
```

#### 原因

子類別試圖覆寫一個不存在的方法，父類別中只有 `SearchEnd`。

#### 解決方案

檢查父類別的虛擬或抽象方法名稱，確保子類別使用正確的名稱：

```csharp
protected override bool SearchEnd(int i, string[] messages)
{
    return String.IsNullOrEmpty(messages[i]);
}
```

#### 教訓

覆寫時，方法名稱、參數和回傳型別必須與父類別完全一致。

### 3. 邏輯錯誤：變數更新與回傳不一致

#### 問題

在 `CountNumberOfWaterballs` 中，我最初寫了：

```csharp
protected override int UpdateResult(string message, int index)
{
    return "Waterball".Equals(message) ? Count++ : Count;
}
```

結果計數不正確，例如遇到第一個 `"Waterball"` 時回傳 0 而不是 1。

#### 原因

後置遞增運算子 `Count++` 先回傳舊值再遞增，導致 `result` 未反映最新計數。

#### 解決方案

先更新 `Count`，再回傳：

```csharp
protected override int UpdateResult(string message, int index)
{
    if ("Waterball".Equals(message))
    {
        Count++;
    }
    return Count;
}
```

#### 教訓

在更新變數並回傳時，避免使用會影響順序的運算子（如 `++`），明確控制邏輯流程。

### 4. 子類別存取父類別區域變數

#### 問題

我曾試圖在子類別的 `Compare` 方法中存取 `Search` 的區域變數 `variable`，導致：

```
Cannot resolve symbol 'variable'
```

#### 原因

區域變數的作用域僅限於定義它的方法，子類別無法直接存取。

#### 解決方案

- **方法 1：使用 ref 參數**：

  修改父類別方法簽名，將變數傳遞給子類別：

  ```csharp
  protected abstract bool Compare(string[] messages, string? message, ref T currentValue);
  ```

  子類別實現：

  ```csharp
  protected override bool Compare(string[] messages, string? message, ref string currentValue)
  {
      if (message.Length > currentValue.Length) { currentValue = message; return true; }
      return false;
  }
  ```

- **方法 2：使用類別欄位**：

  在類別中定義欄位，讓子類別直接操作：

  ```csharp
  protected T currentValue;
  ```

#### 教訓

若子類別需要存取父類別的狀態，必須透過參數傳遞或類別層級的欄位。

## 四、設計抽象類別的建議

1. **明確定義型別**：
    - 在使用泛型時，決定是否需要可為 null 的型別（`T?`），並與子類別保持一致。
2. **方法封裝**：
    - 使用 `protected` 限制子類別存取，避免外部直接呼叫內部邏輯。
3. **樣板方法結構**：
    - 將通用流程放在具體方法中，將可變部分定義為抽象或虛擬方法。
4. **測試與驗證**：
    - 每次修改後，撰寫簡單的測試程式，確保邏輯正確。

## 五、結語

透過這篇文章，我從基本的抽象類別設計開始，逐步進階到樣板方法模式，並解決了型態錯誤、覆寫問題和邏輯錯誤。這些經驗教會我如何在 C# 中設計靈活且穩健的抽象類別和子類別結構。希望這些內容也能幫助你在未來的程式設計中少走彎路，打造出優雅的物件導向程式碼！