# 更新後架構說明（2026-02-01）

目的：把原有 FSM OOA（A 版本）擴充為支持 HFSM（子狀態機）、Decorator（Hierarchical wrapper）、可插拔的消耗策略（IConsumptionPolicy），並加入 lifecycle API（Start / Stop）與可安全變更的 TriggerContext（WithSignal）。本文件說明核心介面、重要語意、事件流程與遷移指南，供實作與測試使用。

---

## 一、變更總覽（Why / What）

為了解決 HFSM（任意深度子狀態機）與題目中「child-first then parent」的行為要求，我們作了以下主要變更：

- 統一使用 TriggerContext（InputEvent、TContext、LifecycleSignal）作為事件傳遞訊息結構，並新增不可變 helper `WithSignal(...)` 用以產生不同 signal（Entry/Exit/None）的新 context。
- 在 IStateMachine 上新增 lifecycle API：`Start(TriggerContext)` 與 `Stop(TriggerContext)`；`Start` 會執行 initial state's Entry 並觸發 ResolveAutomaticTransitions，回傳 `FsmResult`。
- 子狀態包裝：`SubMachineState` 保留（Adapter / Facade），負責啟動/停止內部機器並暴露 `InternalMachine` 給 Hierarchical decorator 使用。Entry 不再自動 forward 原始外部事件。
- 引入 `StateMachineDecorator` 抽象層與 `HierarchicalStateMachine` 作為 concrete decorator，實作 child-first dispatch 與與 `IConsumptionPolicy` 的協調（bubble / consume 決策）。
- `FiniteStateMachine` 的 `Handle(ctx)`、`ExecuteTransition`、`Entry/Exit`、`ResolveAutomaticTransitions` 進行語意調整以支援 new lifecycle 與 HFSM。

---

## 二、關鍵資料模型與介面（摘要）

以下列出最重要的類別／介面與���要方法簽名（pseudo-C# 風格），供設計與實作對齊。

TriggerContext（不可變 / data carrier）
- 欄位（建議）
  - InputEvent? InputEvent
  - TContext Context
  - LifecycleSignal Signal (None | Entry | Exit)
  - string? EventId (選填，用於 idempotency / tracing)
  - DateTime Timestamp (選填)
  - IDictionary<string, object>? Metadata (選填)
- helper
  - TriggerContext WithSignal(LifecycleSignal s)  // 回傳新 TriggerContext（其他欄位同）
  - static TriggerContext ForEntry(TContext ctx) // optional helper

FsmResult（事件處理結果）
- Handled : bool          // 有無被某層處理
- StateChanged : bool     // 有無發生 external transition（任何層）
- MatchedTransition?      // optional: 哪個 transition 被觸發
- ActionLogs?             // optional debug info
- 合併規則：Handled = OR, StateChanged = OR

IStateMachine（Component）
```text
FsmResult Handle(TriggerContext ctx);
FsmResult Start(TriggerContext entryCtx); // signal = Entry (init)
void      Stop(TriggerContext exitCtx);  // signal = Exit
State     CurrentState { get; }
State     InitialState { get; }
```

State（生命週期介面）
```text
void Entry(TriggerContext ctx);
void Do(TriggerContext ctx);
void Exit(TriggerContext ctx);
string Name { get; }
```

Transition / Trigger / Guard / Action（不變）
- Transition: From, To (0..1), Trigger (ITrigger), Guard (IGuard), Action (IAction)
- Triggers read TriggerContext.Signal 和 InputEvent

IConsumptionPolicy（策略介面）
```text
bool ShouldConsume(TriggerContext ctx, FsmResult childResult);
```
- 回傳 true = consume（停止冒泡）；false = bubble（繼續往上處理）

Default/Strict/RuleBasedPolicy 為常用實作範例。

---

## 三、核心類別行為說明（語意/流程）

下面說明各類的職責與事件流（概念化，不含完整程式碼）。

1) FiniteStateMachine
- Start(entryCtx)：
  - 強制 entryCtx.Signal = Entry（使用 WithSignal）
  - CurrentState = InitialState
  - CurrentState.Entry(entryCtx)
  - 呼 ResolveAutomaticTransitions(entryCtx)（處理 OnEntry / eventless transitions）
  - 回傳合併後的 FsmResult（代表初始化造成的變化）
- Handle(ctx)：
  - LookupTransition(ctx)（Trigger.IsTriggered(ctx) && Guard.Evaluate(ctx)）
  - 若無 match，回 FsmResult.Ignored()
  - ExecuteTransition(t, ctx) // 執行 Exit -> Action -> Entry 或 internal action
  - ResolveAutomaticTransitions(ctx) // 用 ctx.WithSignal(Entry)
  - 回傳 Merge(executedResult, autoResult)
- ExecuteTransition(t, ctx)：
  - 若 t.To != null 且 t.From == CurrentState：
    - Exit(t, ctx) -> CurrentState.Exit(ctx)
    - ExecuteAction(t, ctx) -> t.Action.Execute(ctx)
    - Entry(t, ctx) -> CurrentState = t.To; CurrentState.Entry(entryCtx)
    - 回傳 FsmResult.External()
  - 否則（internal）：
    - ExecuteAction(t, ctx)
    - 回傳 FsmResult.Internal()
- ResolveAutomaticTransitions(baseCtx)：
  - ctx = baseCtx.WithSignal(Entry)
  - 迴圈查找 OnEntry/eventless transitions，執行直到穩定或到達上限（防止無限循環）

2) SubMachineState（Adapter / Facade）
- 欄位：IStateMachine InternalMachine
- Entry(ctx)：呼 InternalMachine.Start(entryCtx)（entryCtx = ctx.WithSignal(Entry)）
  - 不 forward 原始外部事件（你選擇不 forward）
- Do(ctx)：可呼 InternalMachine.Handle(ctx) 或 InternalMachine.Update(ctx)（視需求）
- Exit(ctx)：呼 InternalMachine.Stop(exitCtx)
- 提供 InternalMachine 屬性，供 Hierarchical decorator 在 child-first 階段呼叫

3) StateMachineDecorator（抽象）
- 持有 IStateMachine _inner
- 轉發 Handle/Start/Stop 給 _inner（virtual），ConcreteDecorator 可 override

4) HierarchicalStateMachine（ConcreteDecorator）
- Handle(ctx) 的 child-first 流程：
  - childResult = Ignored
  - if _inner.CurrentState is SubMachineState sub:
      childResult = sub.InternalMachine.Handle(ctx)  // child-first
  - if policy.ShouldConsume(ctx, childResult) return childResult
  - parentResult = _inner.Handle(ctx)
  - return Merge(childResult, parentResult)
- Start/Stop 轉發到 inner（或可在 decorator 加入額外 orchestration）

---

## 四、事件處理流程（兩條主線）

A) 外部事件到達（child-first → bubble/consume → parent）
1. Client: Fire(e) → ctx(signal=None)
2. HSM.Handle(ctx):
   - 若 currentState is SubMachineState → childResult = child.InternalMachine.Handle(ctx)
   - policy.ShouldConsume(ctx, childResult)?
     - yes → return childResult (consume)
     - no  → parentResult = inner.Handle(ctx)
   - return Merge(childResult, parentResult)

B) 父層 transition 進入 SubMachineState（Entry init）
1. parent ExecuteTransition → Entry(t, ctx)
2. Entry(t, ctx) 將 CurrentState 設為 SubMachineState 並呼 sub.Entry(entryCtx)（entryCtx = ctx.WithSignal(Entry)）
3. sub.Entry(entryCtx) 呼 internalMachine.Start(entryCtx)
4. internalMachine.Start 做 initial state's Entry 與 ResolveAutomaticTransitions（不 forward 原始事件）
5. parentResult 回傳給呼叫者；Decorator 將合併 child/parent 處理結果並回傳

---

## 五、策略（Policy）示意（決策要點）

- DefaultConsumptionPolicy（推薦預設）
  - if childResult.StateChanged == true → Consume
  - else → Bubble
- StrictConsumptionPolicy
  - if childResult.Handled == true → Consume
  - else → Bubble
- RuleBasedPolicy（可配置）
  - 以 (statePath, eventType, transition, timeWindow) 設規則：例如在 KnowledgeKing.Questioning，任何 new message → Consume

策略實作建議：policy.ShouldConsume(ctx, childResult) 接受 ctx 與 childResult，以便在上下文（例如 CurrentState path）做決策。

---

## 六、TriggerContext.WithSignal 的必要性（重點）

- 為何要有 WithSignal：
  - 同一事件在不同階段需用不同 Signal（Entry/Exit/None），不能 mutate 原 ctx，避免 side-effect 與調試困難。
  - 讓 Trigger/Guard/Trigger.IsTriggered 能依 signal 正確分辨（例如 OnEntryTrigger 只在 Entry signal 時返回 true）。
- 建議實作為不可變物件（readonly），WithSignal 回傳新實例，並保留 eventId/timestamp metadata 以便 trace。

---

## 七、遷移與改動清單（給工程師）

要把現有專案升級到新架構，按步驟做：

1. 定義 TriggerContext 類並加入 WithSignal helper、EventId、Timestamp（若尚未有）。
2. 擴充 IStateMachine：新增 Start(TriggerContext) 與 Stop(TriggerContext)。
3. 修改 State.Entry/Do/Exit 以接受 TriggerContext（或提供 overload 幫助轉換）。
4. 改寫 FiniteStateMachine：
   - 實作 Start（InitialState.Entry + ResolveAutomaticTransitions）
   - 確保 Handle 回傳 FsmResult
   - 確保 ExecuteTransition/Entry/Exit 使用 ctx.WithSignal(Entry/Exit)
5. 實作 SubMachineState：
   - Entry 使用 internalMachine.Start(entryCtx)
   - Do/Exit 對應
   - Expose InternalMachine 屬性
6. 新增 StateMachineDecorator 與 HierarchicalStateMachine（child-first + policy）
7. 加入 IConsumptionPolicy 與幾個預設實作（Default/Strict），在測試時注入不同 policy 驗證行為
8. 撰寫 acceptance tests（king 流、knowledge-answer 流、record 流、nested HFSM）
9. 加 logging（在每個 Handle / ExecuteTransition / Start / policy decision 點）

---

## 八、測試向量（必要驗收用）
- TC1: king @bot（Normal.DefaultConversation is sub）
  - child.Handle: Handled=true, StateChanged=false
  - DefaultPolicy -> Bubble
  - parent.Handle => Transition to KnowledgeKing => final StateChanged=true
- TC2: KnowledgeKing answer
  - child.Handle: Handled=true, StateChanged=false
  - StrictPolicy -> Consume
  - parent.Handle not called
- TC3: Parent enters SubMachineState
  - parent.ExecuteTransition enters SubMachineState
  - sub.Entry calls internal.Start(entryCtx)
  - internal.Start runs initial Entry + ResolveAutomaticTransitions
- TC4: nested HFSM
  - inner-most handles and consumes -> intermediate/outer not invoked
- TC5: ResolveAutomaticTransitions safety
  - ensure max rounds cap prevents infinite loops

---

## 九、實務注意事項（運行時）
- 非同步 action：若 Action 會非同步完成，應將非同步完成視為另一次事件或明確定義 propagation 規則（此設計討論內推：action 同步完成後決定冒泡）。
- 並行與競爭：Quota 扣款、broadcast 狀態等需同步保護（鎖或 actor）。
- 可觀察性：每次 Handle/Start 要記錄 ctx.EventId + current state path + childResult + policy decision + parentResult（便於重放問題）。
- Idempotency：若同一事件可能被 retry 或 forward（你目前不 forward），在 action 層做去重判斷（使用 EventId）。

---

## 十、結語與下一步建議

- 現在你已選擇不做 forward，架構保持較簡潔：SubMachineState 作為生命週期 adapter，Decorator（HierarchicalStateMachine）負責 child-first dispatch 並委由 policy 決定 Bubble/Consume。Start/Stop API 提供清晰的 initialization semantics。
- 建議下一步：
  1. 把 TriggerContext 與 FsmResult 類先實作並寫單元測試（immutability，WithSignal 行為）。
  2. 在 FiniteStateMachine 實作 Start/Handle/ExecuteTransition，並用簡單的狀態與 transition 測試上述 TC1~TC3。
  3. 實作 HierarchicalStateMachine 與 DefaultPolicy，對照題目的 sample input 驗收行為。
- 我可以針對「TriggerContext 類別骨架」、「FiniteStateMachine 的關鍵方法（Start/Handle/ExecuteTransition）」或「HierarchicalStateMachine pseudo-code」提供更精確的 C# 片段，你要我先產出哪一個？
